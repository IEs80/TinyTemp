/*
 * oled.c
 *
 * Created: 12/1/2026 23:45:12
 *  Author: IESz
 */ 


#include "oled.h"
#include "i2c.h"



//Global variables

// [0] Command: Right Horizontal Scroll
// [1] A: Dummy
// [2] B: Start at Page 0
// [3] C: Slow Speed (256 frames)
// [4] D: End at Page 7 (Bottom of screen)
// [5] E: Dummy
// [6] F: Dummy
volatile uint8_t shift_setup_r[]  = { 0x26, 0x00, 0x00, 0x03, 0x07, 0x00, 0xFF };

// [0] Command: Right Horizontal Scroll
// [1] A: Dummy
// [2] B: Start at Page 0
// [3] C: Slow Speed (256 frames)
// [4] D: End at Page 7 (Bottom of screen)
// [5] E: Vertical Scrolling Offset
volatile uint8_t scroll_setup_r[]  = { 0x29, 0x00, 0x00, 0x03, 0x07, 0x00};


const uint8_t font5x7[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, // Space (32)
	0x00, 0x00, 0x5F, 0x00, 0x00, // !
	0x00, 0x07, 0x00, 0x07, 0x00, // "
	0x14, 0x7F, 0x14, 0x7F, 0x14, // #
	0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
	0x23, 0x13, 0x08, 0x64, 0x62, // %
	0x36, 0x49, 0x55, 0x22, 0x50, // &
	0x00, 0x05, 0x03, 0x00, 0x00, // '
	0x00, 0x1C, 0x22, 0x41, 0x00, // (
	0x00, 0x41, 0x22, 0x1C, 0x00, // )
	0x14, 0x08, 0x3E, 0x08, 0x14, // *
	0x08, 0x08, 0x3E, 0x08, 0x08, // +
	0x00, 0x50, 0x30, 0x00, 0x00, // ,
	0x08, 0x08, 0x08, 0x08, 0x08, // -
	0x00, 0x60, 0x60, 0x00, 0x00, // .
	0x20, 0x10, 0x08, 0x04, 0x02, // /
	0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
	0x00, 0x42, 0x7F, 0x40, 0x00, // 1
	0x42, 0x61, 0x51, 0x49, 0x46, // 2
	0x21, 0x41, 0x45, 0x4B, 0x31, // 3
	0x18, 0x14, 0x12, 0x7F, 0x10, // 4
	0x27, 0x45, 0x45, 0x45, 0x39, // 5
	0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
	0x01, 0x71, 0x09, 0x05, 0x03, // 7
	0x36, 0x49, 0x49, 0x49, 0x36, // 8
	0x06, 0x49, 0x49, 0x29, 0x1E, // 9
	0x00, 0x36, 0x36, 0x00, 0x00, // :
	0x00, 0x56, 0x36, 0x00, 0x00, // ;
	0x08, 0x14, 0x22, 0x41, 0x00, // <
	0x14, 0x14, 0x14, 0x14, 0x14, // =
	0x00, 0x41, 0x22, 0x14, 0x08, // >
	0x02, 0x01, 0x51, 0x09, 0x06, // ?
	0x32, 0x49, 0x79, 0x41, 0x3E, // @
	0x7E, 0x11, 0x11, 0x11, 0x7E, // A
	0x7F, 0x49, 0x49, 0x49, 0x36, // B
	0x3E, 0x41, 0x41, 0x41, 0x22, // C
	0x7F, 0x41, 0x41, 0x22, 0x1C, // D
	0x7F, 0x49, 0x49, 0x49, 0x41, // E
	0x7F, 0x09, 0x09, 0x09, 0x01, // F
	0x3E, 0x41, 0x49, 0x49, 0x7A, // G
	0x7F, 0x08, 0x08, 0x08, 0x7F, // H
	0x00, 0x41, 0x7F, 0x41, 0x00, // I
	0x20, 0x40, 0x41, 0x3F, 0x01, // J
	0x7F, 0x08, 0x14, 0x22, 0x41, // K
	0x7F, 0x40, 0x40, 0x40, 0x40, // L
	0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
	0x7F, 0x04, 0x08, 0x10, 0x7F, // N
	0x3E, 0x41, 0x41, 0x41, 0x3E, // O
	0x7F, 0x09, 0x09, 0x09, 0x06, // P
	0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
	0x7F, 0x09, 0x19, 0x29, 0x46, // R
	0x46, 0x49, 0x49, 0x49, 0x31, // S
	0x01, 0x01, 0x7F, 0x01, 0x01, // T
	0x3F, 0x40, 0x40, 0x40, 0x3F, // U
	0x1F, 0x20, 0x40, 0x20, 0x1F, // V
	0x3F, 0x40, 0x38, 0x40, 0x3F, // W
	0x63, 0x14, 0x08, 0x14, 0x63, // X
	0x07, 0x08, 0x70, 0x08, 0x07, // Y
	0x61, 0x51, 0x49, 0x45, 0x43  // Z
};




/*
	@fn: set_page
	@brief: sets display page
	@params: page numer (0 to 7)
	@returns: -
	
*/
void set_page(uint8_t page)
{
	//0xb0 - 0xb7
	if(page >= 0 && page <=7)
	{
		attiny_i2c_send_byte(OLED_ADDR_W,OLED_CONTROL_BYTE,(0xB0|(0x0F&page)));
	}
}


/*
	@fn: set_column
	@brief: sets display column
	@params: column number (0 to 127)
	@returns: -
*/
void set_column(uint8_t column)
{
	
	if(column>=0 && column<128)
	{
		//add column offset
		column+=2;
		attiny_i2c_send_byte(OLED_ADDR_W,OLED_CONTROL_BYTE,(0x0F&column)); //lower column address bits
		attiny_i2c_send_byte(OLED_ADDR_W,OLED_CONTROL_BYTE,(0x10|((0xF0&column)>>4))); //higger column address bits				
	}

}
//
//void set_row(uint8_t row);
//


/*
	@fn:	oled_clean
	@brief:	Set memory all memory to 0 (or 1 if inverted mode is selected)
	@param: 
		mode: defines if device is in standard or inverted mode
	@return:
*/
void oled_clean(uint8_t mode)
{
	//We need to send 0s to all the screen
	uint8_t page_index = 0;
	uint8_t colu_index = 0;


	
	for(page_index=0;page_index<OLED_PAGES;page_index++)
	{
			//increase page
			attiny_i2c_send_byte(OLED_ADDR_W,OLED_CONTROL_BYTE,(0xB0|(0x0F&page_index)));
			
			//set col address to 0
			attiny_i2c_send_byte(OLED_ADDR_W,OLED_CONTROL_BYTE,(0x02));
			attiny_i2c_send_byte(OLED_ADDR_W,OLED_CONTROL_BYTE,(0x10));
		
			//write all 00s to memory
			for(colu_index=0;colu_index<OLED_WIDTH;colu_index++)
			{
				attiny_i2c_send_byte(OLED_ADDR_W,OLED_GDDRAMW_BYTE,0x00);
			}
			

			TWI_DELAY(); //it needs to be addedd		
	}
}

/*
	@fn:	oled_write_byte
	@brief:	writes one byte to OLED GDRAM
	@param: 
		c: byte to be written to GDRAM
	@return:
*/
void oled_write_byte(uint8_t c)
{
	attiny_i2c_send_byte(OLED_ADDR_W,OLED_GDDRAMW_BYTE,c);
}

/*
	@fn:	oled_print
	@brief:	prints text on the display
	@param: 
		data:	text to be printed ()
		page:	the page on to write the text
		column: the column on to write the text
	@return:
*/
void oled_print(char* data,uint8_t page, uint8_t column)
{
	uint8_t i = 0;
	uint8_t text_length = 0;	//stores text total length
	uint8_t character = ' ';	//stores current popped character
	uint16_t font_index = 0;	//current index for the font table 
	uint8_t pixel_slice = 0;	//current slice of the character to be drawn
	uint8_t slice_index = 0;	//
	
	text_length = strlen(data);
	
	//set page
	set_page(page);
	
	//set column
	set_column(column);
	
	//TODO: check if the text has space to be displayed, given the column number
	
	
	//extract character
	for(i=0;i<text_length;i++)
	{
		//pop character from string
		character = data[i];
		
		// Calculate start index in Flash memory
		//sustract "32" because we don't include the first 32 invisible characters
		//multiply by 5, because each character consists of 5 bytes
		font_index = (character - FONT_TABLE_OFFSET) * FONT_TABBLE_CHAR_LEN;
		
		//draw character
		for(slice_index=0;slice_index<FONT_TABBLE_CHAR_LEN;slice_index++)
		{
			//read the character slice from the font table in flash memory
			pixel_slice = pgm_read_byte(&font5x7[font_index + slice_index]);
			oled_write_byte(pixel_slice);	
		}
		//leave one pixel column separation
		oled_write_byte(0x00);
			
	}
		
}